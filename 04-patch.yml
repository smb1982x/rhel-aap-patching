---
# JOB TEMPLATE NOTE:
# - Expects verify_success_hosts from previous workflow step
# - Extra vars: patch_strategy (optional: 'auto', 'conditional', 'package_only')

- name: Validate hosts available for patching
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Check if verification produced any successful hosts
      fail:
        msg: "No hosts available for patching - verify_success_hosts is empty"
      when: ansible_stats.data.verify_success_hosts | default([]) | length == 0

    - name: Create dynamic inventory group for patching with temp directory config
      add_host:
        hostname: "{{ item }}"
        groups: "patch_targets"
        # Set ansible_remote_tmp at host level for proper precedence
        ansible_remote_tmp: "/tmp/ansible-temp/{{ ansible_user | default(ansible_ssh_user | default('ansible')) }}"
      loop: "{{ ansible_stats.data.verify_success_hosts | default([]) }}"

- name: Prepare remote temp directory for Ansible operations
  hosts: patch_targets
  gather_facts: false
  become: true
  ignore_unreachable: true  # Handle SSH/connection failures  
  ignore_errors: true       # Handle task failures
  any_errors_fatal: false   # Don't stop on individual failures
  tasks:
    - name: Create Ansible temp base directory
      file:
        path: "/tmp/ansible-temp"
        state: directory
        mode: '1777'  # Sticky bit + world writable
        owner: "{{ ansible_user | default(ansible_ssh_user | default('ansible')) }}"
        group: "{{ ansible_user | default(ansible_ssh_user | default('ansible')) }}"
      failed_when: false

    - name: Create user-specific temp directory
      file:
        path: "/tmp/ansible-temp/{{ ansible_user | default(ansible_ssh_user | default('ansible')) }}"
        state: directory
        mode: '0755'
        owner: "{{ ansible_user | default(ansible_ssh_user | default('ansible')) }}"
        group: "{{ ansible_user | default(ansible_ssh_user | default('ansible')) }}"
      failed_when: false

- name: Patch servers with specific repository control
  hosts: patch_targets
  gather_facts: true  # Need facts for OS version detection
  become: true
  ignore_unreachable: true  # Handle SSH/connection failures  
  ignore_errors: true       # Handle task failures
  any_errors_fatal: false   # Don't stop on individual failures
  vars:
    patch_async_timeout: "{{ patch_async_timeout | default(14400) }}"  # 4h
    patch_poll_interval: "{{ patch_poll_interval | default(60) }}"
    patch_strategy: "{{ patch_strategy | default('auto') }}"  # auto, conditional, package_only
  tasks:
    - name: Determine RHEL version and set repository list
      set_fact:
        rhel_repos: >-
          {%- if ansible_distribution_major_version | int in [6, 7] -%}
          ["rhel-7-server-els-optional-rpms", "rhel-7-server-els-rpms"]
          {%- elif ansible_distribution_major_version | int == 8 -%}
          ["rhel-8-for-x86_64-appstream-rpms", "rhel-8-for-x86_64-baseos-rpms"]
          {%- elif ansible_distribution_major_version | int == 9 -%}
          ["rhel-9-for-x86_64-baseos-rpms", "rhel-9-for-x86_64-appstream-rpms"]
          {%- else -%}
          []
          {%- endif -%}
        repo_args: >-
          {%- if ansible_distribution_major_version | int in [6, 7] -%}
          --disablerepo=* --enablerepo=rhel-7-server-els-optional-rpms --enablerepo=rhel-7-server-els-rpms
          {%- elif ansible_distribution_major_version | int == 8 -%}
          --disablerepo=* --enablerepo=rhel-8-for-x86_64-appstream-rpms --enablerepo=rhel-8-for-x86_64-baseos-rpms
          {%- elif ansible_distribution_major_version | int == 9 -%}
          --disablerepo=* --enablerepo=rhel-9-for-x86_64-baseos-rpms --enablerepo=rhel-9-for-x86_64-appstream-rpms
          {%- else -%}
          
          {%- endif -%}

    - name: Display detected system information
      debug:
        msg: |
          Host: {{ inventory_hostname }}
          OS: {{ ansible_distribution }} {{ ansible_distribution_version }}
          Major Version: {{ ansible_distribution_major_version }}
          Package Manager: {{ ansible_facts.pkg_mgr | default('unknown') }}
          Strategy: {{ patch_strategy }}
          Temp Directory: {{ ansible_remote_tmp }}
          Repositories: {{ rhel_repos }}
          Repo Args: {{ repo_args }}

    - name: Ensure temp directory exists and is accessible
      file:
        path: "{{ ansible_remote_tmp }}"
        state: directory
        mode: '0755'
      failed_when: false

    - name: Fail if RHEL version is not supported
      fail:
        msg: "Unsupported RHEL version: {{ ansible_distribution_major_version }}. Only RHEL 6, 7, 8, and 9 are supported."
      when: ansible_distribution_major_version | int not in [6, 7, 8, 9]

    # Strategy 1: Use DNF with specific repositories (RHEL 8/9)
    - name: Start package update using DNF with specific repositories
      shell: "dnf update -y {{ repo_args }}"
      async: "{{ patch_async_timeout }}"
      poll: 0
      register: dnf_repo_async
      failed_when: false
      when:
        - patch_strategy in ['auto', 'conditional', 'package_only']
        - ansible_distribution_major_version | int in [8, 9]
        - ansible_facts.pkg_mgr in ['dnf']

    - name: Wait for DNF repository-specific update to finish (with connection retry)
      block:
        - name: Poll DNF async job status with connection retry
          async_status:
            jid: "{{ dnf_repo_async.ansible_job_id }}"
          register: dnf_repo_wait
          until: (dnf_repo_wait.finished | default(0)) | int == 1
          retries: "{{ (patch_async_timeout | int // patch_poll_interval | int) + 1 }}"
          delay: "{{ patch_poll_interval | int }}"
          failed_when: false
      rescue:
        - name: Handle connection failures during async polling
          debug:
            msg: "Connection lost to {{ inventory_hostname }}, attempting reconnection with retries"

        - name: Retry async status check after connection failure
          async_status:
            jid: "{{ dnf_repo_async.ansible_job_id }}"
          register: dnf_repo_wait_retry
          retries: 3
          delay: 10
          until: (dnf_repo_wait_retry.finished | default(0)) | int == 1
          failed_when: false
          vars:
            # Increase SSH timeout values for reconnection attempts
            ansible_ssh_timeout: 30
            ansible_connect_timeout: 30

        - name: Set final DNF result from retry attempt
          set_fact:
            dnf_repo_wait: "{{ dnf_repo_wait_retry if dnf_repo_wait_retry is defined else dnf_repo_wait }}"

        - name: Mark as connection failure if all retries exhausted
          set_fact:
            dnf_connection_failed: true
          when: 
            - dnf_repo_wait_retry is defined
            - dnf_repo_wait_retry.unreachable | default(false)
      when: dnf_repo_async is defined and dnf_repo_async.ansible_job_id is defined

    # Strategy 2: Use YUM with specific repositories (RHEL 6/7 or fallback)
    - name: Wait for YUM repository-specific update to finish (with connection retry)
      block:
        - name: Poll YUM async job status with connection retry
          async_status:
            jid: "{{ yum_repo_async.ansible_job_id }}"
          register: yum_repo_wait
          until: (yum_repo_wait.finished | default(0)) | int == 1
          retries: "{{ (patch_async_timeout | int // patch_poll_interval | int) + 1 }}"
          delay: "{{ patch_poll_interval | int }}"
          failed_when: false
      rescue:
        - name: Handle connection failures during YUM async polling
          debug:
            msg: "Connection lost to {{ inventory_hostname }}, attempting reconnection with retries"

        - name: Retry YUM async status check after connection failure
          async_status:
            jid: "{{ yum_repo_async.ansible_job_id }}"
          register: yum_repo_wait_retry
          retries: 3
          delay: 10
          until: (yum_repo_wait_retry.finished | default(0)) | int == 1
          failed_when: false
          vars:
            ansible_ssh_timeout: 30
            ansible_connect_timeout: 30

        - name: Set final YUM result from retry attempt
          set_fact:
            yum_repo_wait: "{{ yum_repo_wait_retry if yum_repo_wait_retry is defined else yum_repo_wait }}"

        - name: Mark as connection failure if all retries exhausted
          set_fact:
            yum_connection_failed: true
          when: 
            - yum_repo_wait_retry is defined
            - yum_repo_wait_retry.unreachable | default(false)
      when: yum_repo_async is defined and yum_repo_async.ansible_job_id is defined

    # Cleanup async job files
    - name: Cleanup async job files
      async_status:
        jid: "{{ item }}"
        mode: cleanup
      changed_when: false
      failed_when: false
      loop:
        - "{{ dnf_repo_async.ansible_job_id | default('') }}"
        - "{{ yum_repo_async.ansible_job_id | default('') }}"
      when: item != ''

    # Determine overall patch result
    # Update the patch result calculation to account for connection failures
    - name: Calculate patch result (accounting for connection retries)
      set_fact:
        patch_result_status: >-
          {{
            (
              (dnf_repo_wait.finished | default(0)) | int == 1 and 
              not (dnf_repo_wait.failed | default(false)) and
              (dnf_repo_wait.rc | default(1)) == 0 and
              not (dnf_connection_failed | default(false))
            ) or (
              (yum_repo_wait.finished | default(0)) | int == 1 and 
              not (yum_repo_wait.failed | default(false)) and
              (yum_repo_wait.rc | default(1)) == 0 and
              not (yum_connection_failed | default(false))
            )
          }}
        patch_method: >-
          {{
            'dnf' if (
              (dnf_repo_wait.finished | default(0)) | int == 1 and 
              not (dnf_repo_wait.failed | default(false)) and
              (dnf_repo_wait.rc | default(1)) == 0 and
              not (dnf_connection_failed | default(false))
            ) else 'yum'
          }}
        patch_connection_issue: "{{ dnf_connection_failed | default(false) or yum_connection_failed | default(false) }}"

    - name: Record successful patch results
      set_stats:
        data:
          patch_success_hosts: "{{ ansible_stats.data.patch_success_hosts | default([]) + [inventory_hostname] }}"
          patch_method_map: >-
            {{
              ansible_stats.data.patch_method_map | default({}) | combine({
                inventory_hostname: patch_method
              })
            }}
          patch_repos_used: >-
            {{
              ansible_stats.data.patch_repos_used | default({}) | combine({
                inventory_hostname: rhel_repos
              })
            }}
        aggregate: true
        per_host: false
      when: patch_result_status | default(false)

    - name: Record failed patch results (including connection failures)
      set_stats:
        data:
          patch_failed_hosts: "{{ ansible_stats.data.patch_failed_hosts | default([]) + [inventory_hostname] }}"
          patch_failure_reasons: >-
            {{
              ansible_stats.data.patch_failure_reasons | default({}) | combine({
                inventory_hostname: 
                  "Connection failure after retries" if patch_connection_issue | default(false)
                  else dnf_repo_wait.stderr | default(yum_repo_wait.stderr | default('Unknown patching error'))
              })
            }}
        aggregate: true
        per_host: false
      when: not (patch_result_status | default(false)) or patch_connection_issue | default(false)

    - name: Display patch result for this host
      debug:
        msg: |
          Host: {{ inventory_hostname }}
          RHEL Version: {{ ansible_distribution_major_version }}
          Patch Status: {{ patch_result_status | default(false) | ternary('SUCCESS', 'FAILED') }}
          Method Used: {{ patch_method }}
          Repositories Used: {{ rhel_repos | join(', ') }}
          {% if not (patch_result_status | default(false)) %}
          Error: {{ dnf_repo_wait.stderr | default(yum_repo_wait.stderr | default('Unknown error')) }}
          {% endif %}

- name: Patch phase summary
  hosts: localhost
  gather_facts: false
  run_once: true
  ignore_errors: true      # CORE FIX: Never fail the workflow 
  any_errors_fatal: false  # CORE FIX: Ensure workflow continues
  tasks:
    - name: Display patching summary
      debug:
        msg: |
          ========================================
          PATCH PHASE COMPLETED
          ========================================
          Target Hosts: {{ ansible_stats.data.verify_success_hosts | default([]) | length }}
          Successful: {{ ansible_stats.data.patch_success_hosts | default([]) | length }}
          Failed: {{ ansible_stats.data.patch_failed_hosts | default([]) | length }}
          Success Rate: {{ ((ansible_stats.data.patch_success_hosts | default([]) | length) * 100.0 / (ansible_stats.data.verify_success_hosts | default([]) | length)) | round(1) }}%
          ========================================
          Successful Hosts: {{ ansible_stats.data.patch_success_hosts | default([]) | join(', ') }}
          Failed Hosts: {{ ansible_stats.data.patch_failed_hosts | default([]) | join(', ') }}
          ========================================
          Repository Usage Summary:
          {% for host in ansible_stats.data.patch_success_hosts | default([]) %}
          - {{ host }}: {{ ansible_stats.data.patch_repos_used[host] | default([]) | join(', ') }}
          {% endfor %}
          ========================================

    # CORE FIX: Always signal success to continue workflow
    - name: Signal workflow success - continue to next playbook
      debug:
        msg: "Patch phase completed successfully. Workflow continues to next step."