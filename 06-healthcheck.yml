---
# JOB TEMPLATE NOTE:
# - Expects reboot_success_hosts from previous workflow step
# - Performs comprehensive post-patch health validation

- name: Validate hosts available for health checking
  hosts: localhost
  gather_facts: false
  ignore_errors: true      # KEY FIX: Don't fail workflow on validation issues
  any_errors_fatal: false  # KEY FIX: Continue workflow even if validation has problems
  tasks:
    - name: Check if reboot produced any successful hosts
      fail:
        msg: "No hosts available for health checking - reboot_success_hosts is empty"
      when: reboot_success_hosts | default([]) | length == 0
      ignore_errors: true   # Let the workflow continue even if no hosts

    - name: Create dynamic inventory group for health checking
      add_host:
        hostname: "{{ item }}"
        groups: "health_targets"
      loop: "{{ reboot_success_hosts | default([]) }}"
      ignore_errors: true

- name: Post-patch health checks
  hosts: health_targets
  become: true
  gather_facts: true
  ignore_unreachable: true  # KEY FIX: Handle unreachable hosts gracefully
  ignore_errors: true       # KEY FIX: Handle task failures gracefully
  any_errors_fatal: false   # KEY FIX: Prevent one host from stopping others
  vars:
    disk_util_warn: "{{ disk_util_warn | default(80) }}"  # percent
  tasks:
    # Initialize health tracking for this host
    - name: Initialize health tracking for this host
      set_fact:
        host_health_attempted: true
        host_health_successful: false
        host_available: true
        host_health_error: ""
      ignore_errors: true
      failed_when: false

    - name: Test host availability
      block:
        - name: Verify host is responsive
          setup:
          register: setup_result
      rescue:
        - name: Mark host as unavailable
          set_fact:
            host_available: false
            host_health_error: "Host unreachable - cannot gather facts"
          ignore_errors: true
          failed_when: false

    - name: Collect service facts
      service_facts:
      when: host_available | default(true)
      ignore_errors: true
      failed_when: false

    - name: Check disk usage threshold
      shell: |
        set -o pipefail
        df -P -x tmpfs -x devtmpfs | awk 'NR>1 {gsub("%%",$5); if ($5+0 > {{ disk_util_warn }}) {exit 1}}'
      register: disk_check
      changed_when: false
      when: host_available | default(true)
      ignore_errors: true
      failed_when: false

    - name: Check SELinux status
      command: getenforce
      register: selinux_check
      changed_when: false
      when: host_available | default(true)
      ignore_errors: true
      failed_when: false

    - name: Verify SSH service is running
      set_fact:
        ssh_running: "{{ (ansible_facts.services['sshd.service'] | default({'state':'stopped'})).state == 'running' }}"
      when: 
        - host_available | default(true)
        - ansible_facts.services is defined
      ignore_errors: true
      failed_when: false

    - name: Set SSH status if service facts unavailable
      set_fact:
        ssh_running: true  # If we can connect, SSH is running
      when: 
        - host_available | default(true)
        - ssh_running is not defined
      ignore_errors: true
      failed_when: false

    - name: Check system uptime and load
      shell: uptime
      register: uptime_check
      changed_when: false
      when: host_available | default(true)
      ignore_errors: true
      failed_when: false

    - name: Verify kernel version updated (if applicable)
      shell: uname -r
      register: kernel_version
      changed_when: false
      when: host_available | default(true)
      ignore_errors: true
      failed_when: false

    - name: Calculate overall health status
      set_fact:
        health_status: >-
          {{
            host_available | default(true) and
            (disk_check.rc | default(1)) == 0 and
            (selinux_check.rc | default(1)) == 0 and
            (selinux_check.stdout | default('Unknown')) in ['Enforcing','Permissive'] and
            ssh_running | default(false) and
            (uptime_check.rc | default(1)) == 0
          }}
        health_error_details: >-
          {{
            'Host unreachable' if not (host_available | default(true)) else
            'Disk usage high' if (disk_check.rc | default(1)) != 0 else
            'SELinux issue' if (selinux_check.rc | default(1)) != 0 or (selinux_check.stdout | default('Unknown')) not in ['Enforcing','Permissive'] else
            'SSH not running' if not (ssh_running | default(false)) else
            'Uptime check failed' if (uptime_check.rc | default(1)) != 0 else
            'Unknown health check error'
          }}
      ignore_errors: true
      failed_when: false

    - name: Record successful health check results
      set_stats:
        data:
          health_success_hosts: "{{ health_success_hosts | default([]) + [inventory_hostname] }}"
          health_details_map: >-
            {{
              health_details_map | default({}) | combine({
                inventory_hostname: {
                  'disk_usage_ok': (disk_check.rc | default(1)) == 0,
                  'selinux_status': selinux_check.stdout | default('Unknown'),
                  'ssh_running': ssh_running | default(false),
                  'uptime': uptime_check.stdout | default('Unknown'),
                  'kernel_version': kernel_version.stdout | default('Unknown')
                }
              })
            }}
        aggregate: true
        per_host: false
      when: health_status | default(false)
      ignore_errors: true
      failed_when: false

    - name: Record failed health check results
      set_stats:
        data:
          health_failed_hosts: "{{ health_failed_hosts | default([]) + [inventory_hostname] }}"
          health_failure_details: >-
            {{
              health_failure_details | default({}) | combine({
                inventory_hostname: {
                  'available': host_available | default(true),
                  'disk_usage_ok': (disk_check.rc | default(1)) == 0,
                  'disk_usage_error': disk_check.stderr | default('') if (disk_check.rc | default(1)) != 0 else '',
                  'selinux_status': selinux_check.stdout | default('Unknown'),
                  'ssh_running': ssh_running | default(false),
                  'uptime_available': (uptime_check.rc | default(1)) == 0,
                  'error_summary': health_error_details
                }
              })
            }}
        aggregate: true
        per_host: false
      when: not (health_status | default(false))
      ignore_errors: true
      failed_when: false

    - name: Display health check results for this host
      debug:
        msg: |
          Host: {{ inventory_hostname }}
          Available: {{ host_available | default(true) }}
          Overall Health: {{ health_status | default(false) | ternary('HEALTHY', 'UNHEALTHY') }}
          Disk Usage: {{ 'OK' if (disk_check.rc | default(1)) == 0 else 'HIGH' }}
          SELinux: {{ selinux_check.stdout | default('Unknown') }}
          SSH Service: {{ 'Running' if ssh_running | default(false) else 'Not Running' }}
          System Uptime: {{ uptime_check.stdout | default('Unknown') }}
          Kernel Version: {{ kernel_version.stdout | default('Unknown') }}
          {% if not (health_status | default(false)) %}
          Error: {{ health_error_details }}
          {% endif %}
      ignore_errors: true
      failed_when: false

- name: Health check phase summary
  hosts: localhost
  gather_facts: false
  run_once: true
  ignore_errors: true      # KEY FIX: Never fail the summary
  any_errors_fatal: false  # KEY FIX: Ensure workflow continues
  tasks:
    - name: Calculate final health statistics
      set_fact:
        total_health_hosts: "{{ reboot_success_hosts | default([]) | length }}"
        successful_health_hosts: "{{ ansible_stats.data.health_success_hosts | default([]) | length }}"
        failed_health_hosts: "{{ ansible_stats.data.health_failed_hosts | default([]) | length }}"
        health_success_rate: "{{ ((ansible_stats.data.health_success_hosts | default([]) | length) * 100.0 / (reboot_success_hosts | default([]) | length)) | round(1) if (reboot_success_hosts | default([]) | length) > 0 else 0.0 }}"
      ignore_errors: true
      failed_when: false

    - name: Display health check summary
      debug:
        msg: |
          ========================================
          HEALTH CHECK PHASE COMPLETED
          ========================================
          Target Hosts: {{ total_health_hosts }}
          Healthy: {{ successful_health_hosts }}
          Unhealthy: {{ failed_health_hosts }}
          Success Rate: {{ health_success_rate }}%
          ========================================
          Healthy Hosts: {{ ansible_stats.data.health_success_hosts | default([]) | join(', ') }}
          Unhealthy Hosts: {{ ansible_stats.data.health_failed_hosts | default([]) | join(', ') }}
          {% if ansible_stats.data.health_failed_hosts | default([]) | length > 0 %}
          ========================================
          Health Check Failure Details:
          {% for host in ansible_stats.data.health_failed_hosts | default([]) %}
          - {{ host }}: {{ ansible_stats.data.health_failure_details[host].error_summary | default('Unknown error') }}
          {% endfor %}
          {% endif %}
          ========================================
      ignore_errors: true
      failed_when: false

    # KEY FIX: Always signal success to continue workflow
    - name: Signal workflow success regardless of individual host health failures
      debug:
        msg: "Health check phase completed. Workflow will continue to report generation step."
      ignore_errors: true
      failed_when: false